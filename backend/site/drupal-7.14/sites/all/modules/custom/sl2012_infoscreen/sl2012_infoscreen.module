<?php
/**
 * @file
 * Code for the SL2012 infoscreen feature.
 */
include_once 'sl2012_infoscreen.features.inc';

/**
 * Implements hook_menu().
 */
function sl2012_infoscreen_menu() {
  $items['info'] = array(
    'title' => 'sl2012 info callback',
    'page callback' => 'sl2012_infoscreen_callback',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Get defined tickets
 */
function sl2012_get_news($prefix) {
  // TODO - put in configuration.
  $queue = nodequeue_load_queue_by_name($prefix . 'news');
  $nodes = nodequeue_load_nodes($queue->qid);

  $tickets = array();
  foreach ($nodes as $node) {
    $date = new dateObject($node->field_date[LANGUAGE_NONE][0]['value']);
    $cur_locale = setlocale(LC_ALL, 0);
    setlocale(LC_ALL, 'da_DK');
    $date_unix = $date->format('U');

    $date_formatted = htmlentities(strftime("%a %e/%m", $date_unix));
    setlocale(LC_ALL, $cur_locale);
    $body = field_get_items('node', $node, 'field_body');
    array_push($tickets, '<b>' . $date_formatted . ' - ' .  $node->title . "</b>: " . $body[0]['value']);
  }

  return $tickets;
}

/**
 * Go through all albums and extract content
 */
function sl2012_get_albums($prefix) {

  $queue = nodequeue_load_queue_by_name($prefix . 'slideshow');

  $album_nodes = nodequeue_load_nodes($queue->qid);

  $return_albums = array();
  // Load each album in order, add images from each album to the image list.
  foreach ($album_nodes as $album_node) {

    if($album_node->type == 'album'){
      $images = array();
      $album_images = field_get_items('node', $album_node, 'field_images');
      foreach ($album_images as $image_entity) {
        $image = field_collection_field_get_entity($image_entity);

        if (isset($image->field_image['und'])) {
          $filename = $image->field_image['und'][0]['filename'];
          $image_uri = file_build_uri($filename);
          $src = image_style_url('1080p', $image_uri);
        }
        else {
          $src = '';
        }

        // we force all images into a 1200x800 box, so no need to calculate this
        // but we do it anyways as it forces imagecache to generate the image
	if(is_readable($src)){
	  $imagesize = getimagesize($src);
	}
        $caption = isset($image->field_caption['und']) ? $image->field_caption['und'][0]['safe_value'] : '';

        // remove trailing "Foto: ...."
        $caption = preg_replace('/^(.*)( foto:.*)$/i', '$1', $caption);

        $byline = isset($image->field_byline['und']) ? $image->field_byline['und'][0]['safe_value'] : '';
        $byline = str_replace(array("\r", "\r\n", "\n"), ' ', $byline);

        array_push($images, array(
          'byline' => $byline,
          'caption' => nl2br($caption),
          'src' => $src,
          )
        );
      }

      array_push($return_albums, array(
        'type' => 'image',
        'title' => $album_node->title,
        'duration' => $album_node->field_duration[LANGUAGE_NONE][0]['value'],
        'content' => $images,
        )
      );

    }else if($album_node->type == 'video'){
      $videos = array();
      $album_videoes = field_get_items('node', $album_node, 'field_videoes');
      foreach ($album_videoes as $video_entity) {
        $video = field_collection_field_get_entity($video_entity);

        $video_caption = isset($video->field_video_caption[LANGUAGE_NONE]) ? $video->field_video_caption[LANGUAGE_NONE][0]['safe_value'] : '';
        $video_byline = isset($video->field_video_byline[LANGUAGE_NONE]) ? $video->field_video_byline[LANGUAGE_NONE][0]['safe_value'] : '';
        $video_byline = str_replace(array("\r", "\r\n", "\n"), ' ', $video_byline);

        $video_id = isset($video->field_video_id[LANGUAGE_NONE]) ? $video->field_video_id[LANGUAGE_NONE][0]['safe_value'] : '';


        array_push($videos, array(
          'byline' => $video_byline,
          'caption' => nl2br($video_caption),
          'src' => $video_id,
          )
        );
      }

      array_push($return_albums, array(
        'type' => 'video',
        'title' => $album_node->title,
        'content' => $videos,
        )
      );
    }
  }

  return $return_albums;
}


/**
 * Invoked via implementaiton of hook_menu
 */
function sl2012_infoscreen_callback() {
  $prefix = arg(1);

  if(!empty($prefix)){
      $prefix .= '_';
  }

  $news = sl2012_get_news($prefix);
  $albums = sl2012_get_albums($prefix);

  $output = array(
    'albums' => $albums,
    'news' => $news,
    );
// drupal_add_http_header('Expires', gmdate("D, d M Y H:i:s", time() + 60*2) ." GMT");
  drupal_json_output($output);
}

/**
 * Implements hook_form_FORM_ID_alter
 *
 * Injects a bulk image upload field set into the edit album node page
 */
function sl2012_infoscreen_form_album_node_form_alter(&$form, &$form_state, $form_id) {

  $slideshow_queue = nodequeue_load_queue_by_name('slideshow');
  $tickets_queue = nodequeue_load_queue_by_name('tickets');

  $form['bulk_image_add'] = array(
    '#type' => 'fieldset',
    '#title' => t('Tilføj billeder'),
    '#tree' => TRUE,
    '#weight' => $form['title']['#weight'] + 1,
  );

  $form['bulk_image_add']['bulk_images'] = array(
    '#type' => 'plupload',
    '#title' => t('Billeder'),
    '#description' => t('Billeder der skal tilføjes til albummet'),
  );

  $form['bulk_image_add']['description'] = array(
    '#type' => 'textarea',
    '#title' => t('Gennemtving beskrivelse'),
    '#cols' => 60,
    '#rows' => 5,
    '#description' => t('(OBS: overskriver eventuelle beskrivelser i originalbilleder)'),
  );

  // Attach our own submit callback.
  array_push($form['actions']['submit']['#submit'], 'sl2012_infoscreen_form_album_node_submit');

  // kill the default field-collections form if no images has been attached yet
  $node = $form_state['node'];

  if(!isset($node->field_images) || count($node->field_images[LANGUAGE_NONE]) == 0 ){
    unset($form['field_images']);
  }
}

/**
 * Implementation of hook_submit
 */
function sl2012_infoscreen_form_album_node_submit($form, &$form_state) {
  $saved_files = array();
  $scheme = variable_get('file_default_scheme', 'public') . '://';

  // save each file, napped from plupload.module
  foreach ($form_state['values']['bulk_image_add']['bulk_images'] as $uploaded_file) {
    if ($uploaded_file['status'] == 'done') {
      $source = $uploaded_file['tmppath'];
      $destination = file_stream_wrapper_uri_normalize($scheme . $uploaded_file['name']);
      // Rename it to its original name, and put it in its final home.
      // Note - not using file_move here because if we call file_get_mime
      // (in file_uri_to_object) while it has a .tmp extension, it horks.
      $destination = file_unmanaged_move($source, $destination, FILE_EXISTS_RENAME);
      $file = plupload_file_uri_to_object($destination);
      file_save($file);
      $saved_files[] = $file;
    }
    else {
      // @todo: move this to element validate or something and clean up t().
      form_set_error('pud', "Upload of {$uploaded_file['name']} failed");
    }
  }

  // then go trough each file and create entity instances
  foreach($saved_files as $file){
    // extract exif info
    $size = getimagesize (drupal_realpath($file->uri), $info);

    $iptc = iptcparse($info["APP13"]);

    $image_description = '';
    if(isset($iptc['2#120'][0])){
      $image_description = $iptc['2#120'][0];
    }

    $image_byline = '';
    if(isset($iptc['2#080'][0])){
      $image_byline = $iptc['2#080'][0];
    }

    $images_field = entity_create('field_collection_item', array('field_name' => 'field_images'));
    $images_field->setHostEntity('node', $form_state['node']); // Attach it to the node.

    $images_field->field_image[LANGUAGE_NONE][0]['fid'] = $file->fid;
    $images_field->field_caption[LANGUAGE_NONE][0]['value'] = $image_description;
    $images_field->field_byline[LANGUAGE_NONE][0]['value'] = $image_byline;

    $images_field->save(); // Save field-collection item.
  }
}
